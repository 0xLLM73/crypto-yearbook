{"version":3,"sources":["../src/lib/use-layout-effect.ts","../src/use-mention-suggestions.ts","../src/use-sync-source.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax */\n\nimport { useEffect, useLayoutEffect as useOriginalLayoutEffect } from \"react\";\n\n// On React 18.2.0 and earlier, useLayoutEffect triggers a warning when\n// executed on the server, so this workaround should be used instead.\nexport const useLayoutEffect =\n  typeof window !== \"undefined\" ? useOriginalLayoutEffect : useEffect;\n","import { type MentionData, stableStringify } from \"@liveblocks/core\";\nimport { useEffect, useRef, useState } from \"react\";\n\nimport {\n  useMentionSuggestionsCache,\n  useResolveMentionSuggestions,\n} from \"./room\";\n\nconst MENTION_SUGGESTIONS_DEBOUNCE = 500;\n\n/**\n * Normalize mention suggestions as `MentionData[]`.\n *\n * Mention suggestions were previously typed as `string[]`, a list of user IDs,\n * but to support multiple mention kinds (user, group, etc), they're now\n * typed as `MentionData[]`.\n */\nfunction normalizeMentionSuggestions<T extends string[] | MentionData[]>(\n  suggestions: T\n): MentionData[] {\n  return suggestions.map(\n    (suggestion): MentionData =>\n      typeof suggestion === \"string\"\n        ? { kind: \"user\" as const, id: suggestion }\n        : suggestion\n  );\n}\n\n/**\n * @private For internal use only. Do not rely on this hook.\n *\n * Simplistic debounced search, we don't need to worry too much about deduping\n * and race conditions as there can only be one search at a time.\n */\nexport function useMentionSuggestions(roomId: string, search?: string) {\n  const [mentionSuggestions, setMentionSuggestions] = useState<MentionData[]>();\n  const lastInvokedAt = useRef<number>();\n\n  const resolveMentionSuggestions = useResolveMentionSuggestions();\n  const mentionSuggestionsCache = useMentionSuggestionsCache();\n\n  useEffect(() => {\n    if (search === undefined || !resolveMentionSuggestions) {\n      return;\n    }\n\n    const resolveMentionSuggestionsArgs = { text: search, roomId };\n    const mentionSuggestionsCacheKey = stableStringify(\n      resolveMentionSuggestionsArgs\n    );\n    let debounceTimeout: number | undefined;\n    let isCanceled = false;\n\n    const getMentionSuggestions = async () => {\n      try {\n        lastInvokedAt.current = performance.now();\n        const rawMentionSuggestions = await resolveMentionSuggestions(\n          resolveMentionSuggestionsArgs\n        );\n\n        if (!isCanceled) {\n          const normalizedSuggestions = normalizeMentionSuggestions(\n            rawMentionSuggestions\n          );\n          setMentionSuggestions(normalizedSuggestions);\n          mentionSuggestionsCache.set(\n            mentionSuggestionsCacheKey,\n            normalizedSuggestions\n          );\n        }\n      } catch (error) {\n        console.error((error as Error)?.message);\n      }\n    };\n\n    if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {\n      // If there are already cached mention suggestions, use them immediately.\n      const cachedSuggestions = mentionSuggestionsCache.get(\n        mentionSuggestionsCacheKey\n      );\n      setMentionSuggestions(cachedSuggestions);\n    } else if (\n      !lastInvokedAt.current ||\n      Math.abs(performance.now() - lastInvokedAt.current) >\n        MENTION_SUGGESTIONS_DEBOUNCE\n    ) {\n      // If on the debounce's leading edge (either because it's the first invokation or enough\n      // time has passed since the last debounce), get mention suggestions immediately.\n      void getMentionSuggestions();\n    } else {\n      // Otherwise, wait for the debounce delay.\n      debounceTimeout = window.setTimeout(() => {\n        void getMentionSuggestions();\n      }, MENTION_SUGGESTIONS_DEBOUNCE);\n    }\n\n    return () => {\n      isCanceled = true;\n      window.clearTimeout(debounceTimeout);\n    };\n  }, [search, roomId, resolveMentionSuggestions, mentionSuggestionsCache]);\n\n  return mentionSuggestions;\n}\n","import type { SyncSource } from \"@liveblocks/core\";\nimport { kInternal } from \"@liveblocks/core\";\nimport { useEffect, useState } from \"react\";\n\nimport { useClient } from \"./contexts\";\n\n/**\n * @private For internal use only. Do not rely on this hook.\n */\nexport function useSyncSource(): SyncSource | undefined {\n  const client = useClient();\n  const createSyncSource = client[kInternal].createSyncSource;\n  const [syncSource, setSyncSource] = useState<SyncSource | undefined>();\n\n  useEffect(() => {\n    // Create new sync source on mount\n    const newSyncSource = createSyncSource();\n    setSyncSource(newSyncSource);\n    return () => newSyncSource.destroy();\n  }, [createSyncSource]);\n\n  return syncSource;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAAS,WAAW,mBAAmB,+BAA+B;AAI/D,IAAM,kBACX,OAAO,WAAW,cAAc,0BAA0B;;;ACP5D,SAA2B,uBAAuB;AAClD,SAAS,aAAAA,YAAW,QAAQ,gBAAgB;AAO5C,IAAM,+BAA+B;AASrC,SAAS,4BACP,aACe;AACf,SAAO,YAAY;AAAA,IACjB,CAAC,eACC,OAAO,eAAe,WAClB,EAAE,MAAM,QAAiB,IAAI,WAAW,IACxC;AAAA,EACR;AACF;AAQO,SAAS,sBAAsB,QAAgB,QAAiB;AACrE,QAAM,CAAC,oBAAoB,qBAAqB,IAAI,SAAwB;AAC5E,QAAM,gBAAgB,OAAe;AAErC,QAAM,4BAA4B,6BAA6B;AAC/D,QAAM,0BAA0B,2BAA2B;AAE3D,EAAAC,WAAU,MAAM;AACd,QAAI,WAAW,UAAa,CAAC,2BAA2B;AACtD;AAAA,IACF;AAEA,UAAM,gCAAgC,EAAE,MAAM,QAAQ,OAAO;AAC7D,UAAM,6BAA6B;AAAA,MACjC;AAAA,IACF;AACA,QAAI;AACJ,QAAI,aAAa;AAEjB,UAAM,wBAAwB,YAAY;AACxC,UAAI;AACF,sBAAc,UAAU,YAAY,IAAI;AACxC,cAAM,wBAAwB,MAAM;AAAA,UAClC;AAAA,QACF;AAEA,YAAI,CAAC,YAAY;AACf,gBAAM,wBAAwB;AAAA,YAC5B;AAAA,UACF;AACA,gCAAsB,qBAAqB;AAC3C,kCAAwB;AAAA,YACtB;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ,MAAO,OAAiB,OAAO;AAAA,MACzC;AAAA,IACF;AAEA,QAAI,wBAAwB,IAAI,0BAA0B,GAAG;AAE3D,YAAM,oBAAoB,wBAAwB;AAAA,QAChD;AAAA,MACF;AACA,4BAAsB,iBAAiB;AAAA,IACzC,WACE,CAAC,cAAc,WACf,KAAK,IAAI,YAAY,IAAI,IAAI,cAAc,OAAO,IAChD,8BACF;AAGA,WAAK,sBAAsB;AAAA,IAC7B,OAAO;AAEL,wBAAkB,OAAO,WAAW,MAAM;AACxC,aAAK,sBAAsB;AAAA,MAC7B,GAAG,4BAA4B;AAAA,IACjC;AAEA,WAAO,MAAM;AACX,mBAAa;AACb,aAAO,aAAa,eAAe;AAAA,IACrC;AAAA,EACF,GAAG,CAAC,QAAQ,QAAQ,2BAA2B,uBAAuB,CAAC;AAEvE,SAAO;AACT;;;ACtGA,SAAS,iBAAiB;AAC1B,SAAS,aAAAC,YAAW,YAAAC,iBAAgB;AAO7B,SAAS,gBAAwC;AACtD,QAAM,SAAS,UAAU;AACzB,QAAM,mBAAmB,OAAO,SAAS,EAAE;AAC3C,QAAM,CAAC,YAAY,aAAa,IAAIC,UAAiC;AAErE,EAAAC,WAAU,MAAM;AAEd,UAAM,gBAAgB,iBAAiB;AACvC,kBAAc,aAAa;AAC3B,WAAO,MAAM,cAAc,QAAQ;AAAA,EACrC,GAAG,CAAC,gBAAgB,CAAC;AAErB,SAAO;AACT;","names":["useEffect","useEffect","useEffect","useState","useState","useEffect"]}